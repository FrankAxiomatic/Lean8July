#!/usr/bin/env python3
"""
Automated Claude Opus Consultation System
Directly calls Claude Opus via Anthropic API for expert mathematical assistance
"""

import os
import asyncio
import json
from datetime import datetime
from pathlib import Path
import anthropic
from typing import Optional

class AutomatedClaudeConsultation:
    def __init__(self, api_key: Optional[str] = None):
        """Initialize with Anthropic API key"""
        self.api_key = api_key or os.getenv('ANTHROPIC_API_KEY')
        if not self.api_key:
            raise ValueError(
                "Anthropic API key required. Set ANTHROPIC_API_KEY environment variable "
                "or pass api_key parameter."
            )
        
        self.client = anthropic.Anthropic(api_key=self.api_key)
        self.consultation_dir = Path("opus_consultations")
        self.consultation_dir.mkdir(exist_ok=True)
    
    def load_consultation_request(self, filename: str = "opus_advice.md") -> str:
        """Load the consultation request from file"""
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                return f.read()
        except FileNotFoundError:
            raise FileNotFoundError(f"Consultation request file '{filename}' not found")
    
    def call_claude_opus(self, consultation_content: str) -> str:
        """Call Claude Opus with the consultation content"""
        
        # Create a focused prompt for Claude Opus
        prompt = f"""You are Claude Opus, the most advanced mathematical reasoning model. 
I need expert assistance with a Lean 4 formalization problem. Please provide concrete, 
implementable solutions with complete Lean 4 code.

{consultation_content}

Please provide:
1. **Mathematical Analysis**: Deep understanding of the problem
2. **Lean 4 Solution**: Complete, working code to solve the issue
3. **Implementation Strategy**: Step-by-step approach
4. **Advanced Insights**: Research-level mathematical context

Focus on providing concrete, actionable Lean 4 code that can be immediately applied.
"""
        
        try:
            print("🤖 Calling Claude Opus for expert consultation...")
            print(f"📝 Request size: {len(consultation_content):,} characters")
            
            message = self.client.messages.create(
                model="claude-3-opus-20240229",  # Claude Opus
                max_tokens=4000,  # Large response for detailed analysis
                temperature=0.1,  # Low temperature for precise mathematical reasoning
                messages=[{
                    "role": "user",
                    "content": prompt
                }]
            )
            
            response = message.content[0].text
            print(f"✅ Received response: {len(response):,} characters")
            return response
            
        except anthropic.APIError as e:
            raise Exception(f"Anthropic API error: {e}")
        except Exception as e:
            raise Exception(f"Unexpected error calling Claude Opus: {e}")
    
    def save_consultation_response(self, response: str, consultation_id: str) -> str:
        """Save Claude Opus response to file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        response_filename = f"opus_response_{consultation_id}_{timestamp}.md"
        response_path = self.consultation_dir / response_filename
        
        # Create structured response with metadata
        structured_response = f"""# Claude Opus Response - {consultation_id.title()}

**Consultation ID**: {consultation_id}_{timestamp}
**Response Date**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
**Model**: Claude 3 Opus
**Response Length**: {len(response):,} characters

---

{response}

---

**Generated by**: Automated Claude Consultation System
**Next Steps**: 
1. Review the mathematical analysis
2. Implement the provided Lean 4 code
3. Test the solution in your development environment
4. Apply any additional recommendations
"""
        
        with open(response_path, 'w', encoding='utf-8') as f:
            f.write(structured_response)
        
        return str(response_path)
    
    async def run_consultation(self, 
                              consultation_id: str,
                              request_file: str = "opus_advice.md") -> dict:
        """Run complete automated consultation workflow"""
        
        print(f"🚀 Starting automated consultation: {consultation_id}")
        print(f"📂 Request file: {request_file}")
        
        try:
            # Step 1: Load consultation request
            print("\n1️⃣ Loading consultation request...")
            consultation_content = self.load_consultation_request(request_file)
            print(f"   ✅ Loaded {len(consultation_content):,} characters")
            
            # Step 2: Call Claude Opus
            print("\n2️⃣ Calling Claude Opus API...")
            response = self.call_claude_opus(consultation_content)
            
            # Step 3: Save response
            print("\n3️⃣ Saving Claude Opus response...")
            response_path = self.save_consultation_response(response, consultation_id)
            print(f"   ✅ Saved to: {response_path}")
            
            # Step 4: Create summary
            summary = {
                "consultation_id": consultation_id,
                "timestamp": datetime.now().isoformat(),
                "request_file": request_file,
                "response_file": response_path,
                "request_size": len(consultation_content),
                "response_size": len(response),
                "status": "completed"
            }
            
            print(f"\n🎉 Consultation completed successfully!")
            print(f"📊 Response: {len(response):,} characters")
            print(f"💾 Saved to: {response_path}")
            
            return summary
            
        except Exception as e:
            print(f"\n❌ Consultation failed: {e}")
            return {
                "consultation_id": consultation_id,
                "timestamp": datetime.now().isoformat(),
                "status": "failed",
                "error": str(e)
            }

async def main():
    """Main function for direct execution"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Automated Claude Opus Consultation")
    parser.add_argument("consultation_id", help="Consultation identifier")
    parser.add_argument("--request-file", default="opus_advice.md", 
                       help="Request file (default: opus_advice.md)")
    parser.add_argument("--api-key", help="Anthropic API key (or set ANTHROPIC_API_KEY env var)")
    
    args = parser.parse_args()
    
    try:
        consultant = AutomatedClaudeConsultation(api_key=args.api_key)
        result = await consultant.run_consultation(
            consultation_id=args.consultation_id,
            request_file=args.request_file
        )
        
        if result["status"] == "completed":
            print(f"\n✨ Success! Check {result['response_file']} for Claude Opus's expert advice.")
        else:
            print(f"\n💥 Failed: {result.get('error', 'Unknown error')}")
            
    except KeyboardInterrupt:
        print("\n⏹️  Consultation cancelled by user")
    except Exception as e:
        print(f"\n💥 Error: {e}")

if __name__ == "__main__":
    asyncio.run(main()) 